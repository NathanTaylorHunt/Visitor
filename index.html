<!DOCTYPE html>
<html>
    <head>
        <title>Visitor -- DEMO</title>
    </head>
    <body>
        <div id="glCanvasContainer">
            <canvas id="glCanvas" width="480" height="360"></canvas>
        </div>
        <div id="debugContainer">
            <p><span id="debugFPS">{FPS}</span></p>
            <p><span id="debugDist">{DIST}</span></p>
        </div>

        <script id="vertexShader" type="x-shader/x-vertex">
            attribute vec3 position;
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
            precision highp float;

            #define MAX_STEPS 150
            #define EPSILON 0.01
            #define PI 3.14159265

            uniform float time;
            uniform vec2 resolution;

            uniform vec3 camPos;
            //uniform vec3 camRot;

            float SphereDistance(vec3 point, vec3 center, float radius) {
                return length(point - center) - radius;
            }
            
            float sceneSDF(vec3 samplePoint) {
                return SphereDistance(samplePoint, vec3(0.0, 0.0, 0.0), 1.0);
            }

            vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
                vec2 xy = fragCoord - size / 2.0;
                float z = size.y / tan(radians(fieldOfView) / 2.0);
                return normalize(vec3(xy, -z));
            }

            mat4 viewMatrix(vec3 eye, vec3 target, vec3 up) {
                vec3 f = normalize(target - eye);
                vec3 s = normalize(cross(f, up));
                vec3 u = cross(s, f);
                return mat4(
                    vec4(s, 0.0),
                    vec4(u, 0.0),
                    vec4(-f, 0.0),
                    vec4(0.0, 0.0, 0.0, 1.0));
            }

            vec3 estimateNormal(vec3 p) {
                return normalize(vec3(
                    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
                    sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
                ));
            }

            float raymarch(vec3 eye, vec3 marchingDir, float start, float end) {
                float depth = start;
                for (int i = 0; i < MAX_STEPS; i++) {
                    float dist = sceneSDF(eye + depth * marchingDir);
                    if (dist < EPSILON) {
                        return depth;
                    }
                    depth += dist;
                    if (depth >= end) {
                        return end;
                    }
                }
                return end;
            }

            void main() {
                vec3 viewDir = rayDirection(45.0, resolution.xy, gl_FragCoord.xy);
                vec3 eye = camPos;
                vec3 target = vec3(0.0, 0.0, 0.0);

                mat4 viewToWorld = viewMatrix(eye, target, vec3(0.0, 1.0, 0.0));
                vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;

                float minDist = 0.1;
                float maxDist = 100.0;
                float dist = raymarch(eye, worldDir, minDist, maxDist);

                if (dist > maxDist - EPSILON) { // didn't hit anything
                    gl_FragColor = vec4(0.1, 0.1, 0.1, 1.0); // bg color
                    return;
                }

                vec3 p = eye + dist * worldDir;

                vec3 normal = estimateNormal(p);

                gl_FragColor = vec4(normal, 1.0);
            }

        </script>

        <script type="text/javascript">
        
        var canvas;
        var gl;
        var buffer;
        var program;
        var vertexPosition;
        var timeLocation;
        var resolutionLocation;
        var camPosLocation;
        var startTime;
        var lastFramTime;

        var camPos = [0.0, 0.0, 0.0];
        var camMoveSpeed = 0.3;
        var zoomKeyPressed = false;
        var zoom = 10.0;

        var debugFPSDiv = document.querySelector('#debugFPS');
        var debugDistDiv = document.querySelector('#debugDist');
        var debugRefresh = 5;
        var debugTick = 0;

        main();

        function main() {
            canvas = document.querySelector('#glCanvas');
            gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WEBGL IS NOT HERE');
                return;
            }

            // Shaders
            var vertexShader = createShaderFromScript(gl, "vertexShader");
            var fragmentShader = createShaderFromScript(gl, "fragmentShader");
            program = createProgram(gl, vertexShader, fragmentShader);
            timeLocation = gl.getUniformLocation(program, 'time');
            resolutionLocation = gl.getUniformLocation(program, 'resolution');
            camPosLocation = gl.getUniformLocation(program, 'camPos');

            // Buffer Data
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

            startTime = new Date().getTime();

            // Setup input handlers
            document.addEventListener('keydown', function(event) {
                if (event.keyCode == 38) {
                    zoomKeyPressed = true;
                }
            });

            document.addEventListener('keyup', function(event) {
                if (event.keyCode == 38) {
                    zoomKeyPressed = false;
                }
            });

            // Go!
            animate();
        }

        function animate() {
            if (!program) return;
            
            // Update logic
            var frameTime = new Date().getTime();
            var deltaTime = frameTime - lastFramTime;
            if (zoomKeyPressed) {
                zoom -= 0.1;
            }
            camPos[2] = zoom;

            // Render
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.useProgram(program);
            gl.uniform1f(timeLocation, (frameTime - startTime));
            gl.uniform2f(resolutionLocation, 480, 360);
            gl.uniform3f(camPosLocation, camPos[0], camPos[1], camPos[2]);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexPosition);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            gl.disableVertexAttribArray(vertexPosition);

            // Update debug
            debugTick++;
            if (debugTick > debugRefresh) {
                debugTick = 0;

                var fps = 1000.0 / deltaTime;
                debugFPSDiv.innerHTML = "FPS: " + Math.round(fps);

                debugDistDiv.innerHTML = "ZOOM: " + zoom;
            }
            lastFramTime = frameTime;

            // Loop
            requestAnimationFrame(animate);
        }

        function compileShader(gl, shaderSource, shaderType) {
            var shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                // TODO: Better error logging
                throw(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                throw(gl.getProgramInfoLog(program));
            }

            return program;
        }

        function createShaderFromScript(gl, scriptId, opt_shaderType) {
            var shaderScript = document.getElementById(scriptId);
            if (!shaderScript) {
                throw('Missing script: ' + scriptId);
            }

            var shaderSource = shaderScript.text;
            if (!opt_shaderType) {
                if (shaderScript.type == "x-shader/x-vertex") {
                    opt_shaderType = gl.VERTEX_SHADER;
                } else if (shaderScript.type == "x-shader/x-fragment") {
                    opt_shaderType = gl.FRAGMENT_SHADER;
                } else if (!opt_shaderType) {
                    throw("invalid shader type");
                }
            }

            return compileShader(gl, shaderSource, opt_shaderType);
        }

        // Cross-platform requestAnimationFrame
        window.requestAnimationFrame = window.requestAnimationFrame || ( function() {
            return  window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
				        function(  callback, element ) {
                        window.setTimeout( callback, 1000 / 60 );
                    };
        })();
        
        </script>
    </body>
</html>